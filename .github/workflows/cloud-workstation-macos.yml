name: ‚òÅÔ∏è Cloud Workstation - macOS

on:
  workflow_dispatch:
    inputs:
      vnc_resolution:
        description: 'VNC Resolution'
        required: false
        default: '1920x1080'
        type: choice
        options:
          - '1920x1080'
          - '1280x720'
          - '2560x1440'

env:
  VNC_PORT: '5902'
  VNC_GEOMETRY: ${{ github.event.inputs.vnc_resolution || '1920x1080' }}
  WORKSPACE_DIR: '$HOME/Desktop/workspace'
  BACKUP_REPO: 'backup-files'

jobs:
  macos-workstation:
    runs-on: macos-latest
    timeout-minutes: 360
    
    steps:
      - name: üìä System Information
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë         üçé macOS Cloud Workstation Setup                     ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          echo "üñ•Ô∏è  macOS Version: $(sw_vers -productVersion)"
          echo "üíª Chip: $(uname -m)"
          echo "üìÇ User: $(whoami)"
          echo "üîß Resolution: ${{ env.VNC_GEOMETRY }}"
          echo ""

      - name: üñ•Ô∏è Install XQuartz & VNC Server
        run: |
          echo "üì¶ Installing XQuartz and VNC components..."
          
          # Install XQuartz (X11 for macOS)
          brew install --cask xquartz
          
          # Install x11vnc for virtual display VNC
          brew install x11vnc
          
          # Install tigervnc-viewer for testing (optional)
          brew install tiger-vnc
          
          echo "‚úÖ XQuartz and VNC installed"

      - name: üîê Configure VNC Server with Virtual Display
        run: |
          echo "üîß Configuring VNC with virtual X11 display..."
          
          # Set VNC password
          VNC_PASS="${{ secrets.VNC_PASSWORD }}"
          [ -z "$VNC_PASS" ] && VNC_PASS="P@ssw0rd123!"
          
          # Create VNC password file
          mkdir -p ~/.vnc
          x11vnc -storepasswd "$VNC_PASS" ~/.vnc/passwd
          
          # Create workspace directory
          mkdir -p ~/Desktop/workspace
          
          echo "‚úÖ VNC password configured"

      - name: üöÄ Start Virtual Display & VNC Server
        run: |
          echo "üöÄ Starting virtual display and VNC server..."
          
          # Parse resolution
          RESOLUTION="${{ env.VNC_GEOMETRY }}"
          WIDTH=$(echo $RESOLUTION | cut -d'x' -f1)
          HEIGHT=$(echo $RESOLUTION | cut -d'x' -f2)
          
          # Start XQuartz with virtual display
          export DISPLAY=:1
          
          # Use Xvfb-like approach with XQuartz
          # Start headless X server
          /opt/X11/bin/Xvfb :1 -screen 0 ${WIDTH}x${HEIGHT}x24 &
          XVFB_PID=$!
          echo "Xvfb PID: $XVFB_PID"
          
          sleep 3
          
          # Verify X server is running
          if ! ps -p $XVFB_PID > /dev/null 2>&1; then
            echo "‚ö†Ô∏è Xvfb failed, trying alternative..."
            # Alternative: Use XQuartz directly
            /opt/X11/bin/X :1 -screen 0 ${WIDTH}x${HEIGHT}x24 &
            sleep 3
          fi
          
          export DISPLAY=:1
          
          # Start a simple window manager (optional, for better experience)
          # Some lightweight alternatives
          
          # Start x11vnc server
          x11vnc -display :1 \
            -rfbport ${{ env.VNC_PORT }} \
            -passwd "$(cat ~/.vnc/passwd 2>/dev/null || echo 'P@ssw0rd123!')" \
            -forever \
            -shared \
            -noxdamage \
            -noxfixes \
            -noxrecord \
            -bg \
            -o /tmp/x11vnc.log
          
          sleep 3
          
          # Verify VNC is running
          if pgrep -f "x11vnc" > /dev/null; then
            echo "‚úÖ VNC Server running on port ${{ env.VNC_PORT }}"
            echo "üìä VNC Process:"
            pgrep -a x11vnc
          else
            echo "‚ùå VNC failed to start"
            cat /tmp/x11vnc.log 2>/dev/null
            
            # Fallback: Try native screen sharing with workaround
            echo "üîÑ Trying alternative VNC setup..."
            
            # Install and use tightvnc as fallback
            brew install tightvnc 2>/dev/null || true
            
            vncserver :2 -geometry ${{ env.VNC_GEOMETRY }} -depth 24 2>/dev/null || {
              echo "‚ö†Ô∏è VNC setup challenging on macOS - using SSH as backup"
            }
          fi
          
          # Save PID for cleanup
          pgrep x11vnc > /tmp/vnc_pid.txt 2>/dev/null || true

      - name: ‚òÅÔ∏è Setup Cloudflare Tunnel
        run: |
          echo "üåê Setting up Cloudflare tunnel..."
          
          # Install cloudflared
          brew install cloudflare/cloudflare/cloudflared
          
          # Determine which port to tunnel
          VNC_ACTIVE_PORT="${{ env.VNC_PORT }}"
          
          # Start tunnel
          cloudflared tunnel --url tcp://localhost:$VNC_ACTIVE_PORT > /tmp/cloudflare.log 2>&1 &
          CF_PID=$!
          echo $CF_PID > /tmp/cf_pid.txt
          
          echo "‚è≥ Waiting for Cloudflare tunnel..."
          sleep 15
          
          # Extract hostname
          TUNNEL_READY=false
          for i in {1..30}; do
            HOSTNAME=$(grep -oE 'https://[a-z0-9-]+\.trycloudflare\.com' /tmp/cloudflare.log | head -1 | sed 's|https://||')
            if [ -n "$HOSTNAME" ]; then
              echo "$HOSTNAME" > /tmp/cf_host.txt
              echo "‚úÖ Cloudflare tunnel established"
              echo "üîó Hostname: $HOSTNAME"
              TUNNEL_READY=true
              break
            fi
            sleep 2
          done
          
          if [ "$TUNNEL_READY" = false ]; then
            echo "‚ö†Ô∏è Tunnel still initializing..."
            echo "üìã Logs:"
            tail -20 /tmp/cloudflare.log
          fi

      - name: üêç Install Python
        run: |
          echo "üêç Installing Python..."
          brew install python@3.11
          python3 --version
          pip3 --version
          echo "‚úÖ Python installed"

      - name: üì¶ Install Node.js
        run: |
          echo "üì¶ Installing Node.js..."
          brew install node
          node --version
          npm --version
          echo "‚úÖ Node.js installed"

      - name: üíª Install Development Tools
        run: |
          echo "üíª Installing development tools..."
          
          # VS Code (can be accessed via Remote SSH or locally if VNC works)
          brew install --cask visual-studio-code || echo "VS Code install skipped"
          
          # Essential CLI tools
          brew install wget curl jq git
          
          echo "‚úÖ Development tools installed"

      - name: ‚öôÔ∏è Configure Git & Workspace
        run: |
          echo "‚öôÔ∏è Configuring Git..."
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global init.defaultBranch main
          
          mkdir -p ~/Desktop/workspace
          
          echo "‚úÖ Git configured for: ${GITHUB_ACTOR}"

      - name: üì• Restore Projects from Backup
        run: |
          echo "üì• Checking for project backups..."
          
          TOKEN="${{ secrets.GH_TOKEN }}"
          [ -z "$TOKEN" ] && TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          BACKUP_URL="https://x-access-token:${TOKEN}@github.com/${GITHUB_ACTOR}/${{ env.BACKUP_REPO }}.git"
          
          if git ls-remote "$BACKUP_URL" &>/dev/null; then
            echo "üìÇ Backup repository found - restoring projects..."
            git clone --depth=1 "$BACKUP_URL" /tmp/backup-index
            
            if [ -f /tmp/backup-index/README.md ]; then
              RESTORE_COUNT=0
              
              while IFS= read -r REPO_PATH; do
                [ -z "$REPO_PATH" ] && continue
                REPO_NAME=$(basename "$REPO_PATH")
                echo "  üì¶ Restoring: $REPO_NAME"
                
                if git clone --depth=1 \
                  "https://x-access-token:${TOKEN}@github.com/${REPO_PATH}.git" \
                  "$HOME/Desktop/workspace/${REPO_NAME}" 2>/dev/null; then
                  RESTORE_COUNT=$((RESTORE_COUNT + 1))
                  echo "    ‚úÖ Restored"
                else
                  echo "    ‚ö†Ô∏è Failed"
                fi
              done < <(grep -oE '^\s*-\s*\S+' /tmp/backup-index/README.md | sed 's/^.*- *//')
              
              echo "‚úÖ Restored $RESTORE_COUNT project(s)"
            fi
            rm -rf /tmp/backup-index
          else
            echo "üìù No backup repository found"
          fi

      - name: üîÑ Deploy Backup Watcher v3.0
        run: |
          echo "üîß Deploying Backup Watcher v3.0..."
          
          TOKEN="${{ secrets.GH_TOKEN }}"
          [ -z "$TOKEN" ] && TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          cat > ~/backup-watcher.sh << 'EOFWATCHER'
          #!/bin/bash
          
          # BACKUP WATCHER v3.0 - macOS Edition with Full Sync
          WATCH_DIR="$HOME/Desktop/workspace"
          GITHUB_USER="GITHUB_USER_PLACEHOLDER"
          TOKEN="TOKEN_PLACEHOLDER"
          BACKUP_REPO="backup-files"
          LOG_FILE="$HOME/backup-watcher.log"
          TRACKED_FILE="$HOME/.backed-up-projects"
          SYNC_INTERVAL=300
          
          touch "$TRACKED_FILE"
          
          log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"; }
          
          is_synced() { grep -qx "$1" "$TRACKED_FILE" 2>/dev/null; }
          mark_synced() { grep -qx "$1" "$TRACKED_FILE" 2>/dev/null || echo "$1" >> "$TRACKED_FILE"; }
          
          update_index() {
            local PROJECT_NAME="$1"
            (
              rm -rf /tmp/backup-idx-$$
              git clone --depth=1 "https://x-access-token:$TOKEN@github.com/$GITHUB_USER/$BACKUP_REPO.git" /tmp/backup-idx-$$ 2>/dev/null || return
              cd /tmp/backup-idx-$$ 2>/dev/null || return
              if ! grep -q "$GITHUB_USER/$PROJECT_NAME" README.md 2>/dev/null; then
                echo "- $GITHUB_USER/$PROJECT_NAME" >> README.md
                git add . && git commit -m "Add $PROJECT_NAME" 2>/dev/null && git push 2>/dev/null
                log "  ‚úÖ Updated backup index"
              fi
              rm -rf /tmp/backup-idx-$$
            ) &
          }
          
          backup_or_sync() {
            local PROJECT_PATH="$1"
            local PROJECT_NAME=$(basename "$PROJECT_PATH")
            
            [ -z "$(ls -A "$PROJECT_PATH" 2>/dev/null)" ] && return
            cd "$PROJECT_PATH" || return
            
            if [ -d ".git" ]; then
              REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
              
              # External repo - fork it
              if echo "$REMOTE" | grep -q "github.com" && ! echo "$REMOTE" | grep -qi "$GITHUB_USER"; then
                log "üîÑ External repo: $PROJECT_NAME - Forking..."
                curl -s -X POST -H "Authorization: token $TOKEN" -H "Content-Type: application/json" \
                  https://api.github.com/user/repos -d "{\"name\":\"$PROJECT_NAME\",\"private\":true}" >/dev/null 2>&1
                sleep 2
                git remote remove origin 2>/dev/null
                git remote add origin "https://x-access-token:$TOKEN@github.com/$GITHUB_USER/$PROJECT_NAME.git"
                BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
                if git push -u origin "$BRANCH" --force 2>/dev/null; then
                  log "‚úÖ Forked: $PROJECT_NAME"
                  mark_synced "$PROJECT_NAME"
                  update_index "$PROJECT_NAME"
                fi
                return
              fi
              
              # Our repo - sync changes
              if echo "$REMOTE" | grep -qi "$GITHUB_USER"; then
                git add -A 2>/dev/null
                if ! git diff --cached --quiet 2>/dev/null; then
                  git commit -m "Auto-sync: $(date '+%Y-%m-%d %H:%M')" 2>/dev/null
                  git push 2>/dev/null && log "üîÑ Synced: $PROJECT_NAME"
                fi
                mark_synced "$PROJECT_NAME"
                return
              fi
            fi
            
            # New project
            is_synced "$PROJECT_NAME" && return
            log "üì§ New project: $PROJECT_NAME"
            
            curl -s -X POST -H "Authorization: token $TOKEN" -H "Content-Type: application/json" \
              https://api.github.com/user/repos -d "{\"name\":\"$PROJECT_NAME\",\"private\":true}" >/dev/null 2>&1
            sleep 2
            
            [ ! -d ".git" ] && git init
            git add -A
            git commit -m "Initial commit - $(date '+%Y-%m-%d %H:%M')" 2>/dev/null
            git branch -M main
            git remote remove origin 2>/dev/null
            git remote add origin "https://x-access-token:$TOKEN@github.com/$GITHUB_USER/$PROJECT_NAME.git"
            
            if git push -u origin main --force 2>/dev/null; then
              log "‚úÖ Backed up: $PROJECT_NAME"
              mark_synced "$PROJECT_NAME"
              update_index "$PROJECT_NAME"
            fi
          }
          
          log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          log "üëÅÔ∏è  BACKUP WATCHER v3.0 (macOS) STARTED"
          log "   üìÇ Watching: $WATCH_DIR"
          log "   üîÑ Sync Interval: ${SYNC_INTERVAL}s"
          log "   ‚ú® Features: New projects, File changes, External repo forking"
          log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Initial scan
          for dir in "$WATCH_DIR"/*/; do
            [ -d "$dir" ] && backup_or_sync "$dir"
          done
          
          # Continuous sync loop
          while true; do
            sleep $SYNC_INTERVAL
            log "üîÑ Sync cycle..."
            for dir in "$WATCH_DIR"/*/; do
              [ -d "$dir" ] && backup_or_sync "$dir"
            done
          done
          EOFWATCHER
          
          sed -i '' "s|TOKEN_PLACEHOLDER|${TOKEN}|g" ~/backup-watcher.sh
          sed -i '' "s|GITHUB_USER_PLACEHOLDER|${GITHUB_ACTOR}|g" ~/backup-watcher.sh
          chmod +x ~/backup-watcher.sh
          
          nohup bash ~/backup-watcher.sh > /dev/null 2>&1 &
          
          echo "‚úÖ Backup Watcher v3.0 deployed"
          echo "   ‚ú® Continuous sync every 5 min"
          echo "   ‚ú® External repo forking"
          echo "   ‚ú® Full change tracking"

      - name: üí° Keep Alive & Connection Info
        run: |
          CLOUDFLARE_HOST=$(cat /tmp/cf_host.txt 2>/dev/null || echo "")
          
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë                                                              ‚ïë"
          echo "‚ïë    üçé macOS CLOUD WORKSTATION READY  üçé                      ‚ïë"
          echo "‚ïë                                                              ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          
          if [ -n "$CLOUDFLARE_HOST" ]; then
            echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
            echo "‚îÇ üìã STEP 1: Run on your LOCAL machine                           ‚îÇ"
            echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            echo ""
            echo "  cloudflared access tcp --hostname $CLOUDFLARE_HOST --url 127.0.0.1:${{ env.VNC_PORT }}"
            echo ""
            echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
            echo "‚îÇ üñ•Ô∏è  STEP 2: Connect with VNC Viewer                             ‚îÇ"
            echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            echo ""
            echo "  Server:   localhost:${{ env.VNC_PORT }}"
            if [ -n "${{ secrets.VNC_PASSWORD }}" ]; then
              echo "  Password: [Your VNC_PASSWORD secret]"
            else
              echo "  Password: P@ssw0rd123!"
            fi
            echo ""
            echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
            echo "‚îÇ ‚ö†Ô∏è  NOTE: macOS VNC Limitations                                 ‚îÇ"
            echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            echo ""
            echo "  macOS GitHub runners are headless. VNC may show:"
            echo "  - X11 desktop (if XQuartz works)"
            echo "  - Basic terminal interface"
            echo ""
            echo "  üí° For full GUI experience, use Linux workflow instead."
            echo "  üí° macOS is best for: CLI dev, building iOS apps, brew packages"
            echo ""
          else
            echo "‚ö†Ô∏è Cloudflare tunnel still initializing..."
            echo "   Check 'Setup Cloudflare Tunnel' step above for hostname"
          fi
          
          echo ""
          echo "üìä Environment Details:"
          echo "  üçé OS:          macOS $(sw_vers -productVersion)"
          echo "  üíª Chip:        $(uname -m)"
          echo "  üë§ User:        $(whoami)"
          echo "  üìÇ Workspace:   ~/Desktop/workspace"
          echo "  ‚è±Ô∏è  Duration:    6 hours"
          echo "  üîÑ Backup:      v3.0 (Full sync + External repo forking)"
          echo ""
          echo "üí° Terminal Access (if VNC doesn't work):"
          echo "  You can still use this runner via workflow dispatch commands"
          echo "  or by adding SSH step for remote terminal access."
          echo ""
          
          # Keep alive with health monitoring
          RESTART_COUNT=0
          MAX_RESTARTS=5
          
          while true; do
            sleep 1800
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] üíì Heartbeat"
            
            # Cloudflare health check
            if ! pgrep -f "cloudflared" > /dev/null; then
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] üîÑ Restarting Cloudflare tunnel..."
              cloudflared tunnel --url tcp://localhost:${{ env.VNC_PORT }} > /tmp/cloudflare.log 2>&1 &
              sleep 10
            fi
            
            # VNC health check
            if ! pgrep -f "x11vnc" > /dev/null; then
              if [ $RESTART_COUNT -lt $MAX_RESTARTS ]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] üîÑ Restarting VNC..."
                export DISPLAY=:1
                x11vnc -display :1 -rfbport ${{ env.VNC_PORT }} -forever -shared -bg 2>/dev/null
                RESTART_COUNT=$((RESTART_COUNT + 1))
              fi
            fi
            
            # Backup watcher health check
            if ! pgrep -f "backup-watcher.sh" > /dev/null; then
              nohup bash ~/backup-watcher.sh > /dev/null 2>&1 &
            fi
          done
