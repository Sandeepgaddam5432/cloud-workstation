name: ‚òÅÔ∏è Cloud Workstation - Linux (XFCE4)3

on:
  workflow_dispatch:
    inputs:
      vnc_resolution:
        description: 'VNC Resolution'
        required: false
        default: '1920x1080'
        type: choice
        options:
          - '1920x1080'
          - '1280x720'
          - '2560x1440'

env:
  VNC_DISPLAY: ':2'
  VNC_PORT: '5902'
  VNC_GEOMETRY: ${{ github.event.inputs.vnc_resolution || '1920x1080' }}
  VNC_DEPTH: '24'
  WORKSPACE_DIR: '$HOME/Desktop/workspace'
  BACKUP_REPO: 'backup-files'

jobs:
  linux-workstation:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
      - name: üñ•Ô∏è Install XFCE4 Desktop & VNC Stack
        run: |
          echo "üì¶ Installing stable XFCE4 environment..."
          
          sudo apt-get update -qq
          
          # Install XFCE4 core (minimal, no bloat)
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            xfce4 \
            xfce4-terminal \
            xfce4-goodies \
            tigervnc-standalone-server \
            tigervnc-common \
            dbus-x11 \
            xfonts-base \
            xfonts-100dpi \
            xfonts-75dpi \
            fonts-liberation \
            inotify-tools \
            git curl wget jq \
            firefox
          
          echo "‚úÖ XFCE4 desktop installed successfully"

      - name: üîê Configure VNC Server
        run: |
          echo "üîß Configuring VNC with XFCE4..."
          
          # Set VNC password
          VNC_PASS="${{ secrets.VNC_PASSWORD }}"
          if [ -z "$VNC_PASS" ]; then
            VNC_PASS="P@ssw0rd123!"
          fi
          
          mkdir -p ~/.vnc
          echo "$VNC_PASS" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd
          
          # Create XFCE4 config directories
          mkdir -p ~/.config/xfce4/{panel,xfconf,xfce4-session}
          mkdir -p ~/.local/share
          
          # Create optimized VNC startup script for XFCE4
          cat > ~/.vnc/xstartup << 'EOF'
          #!/bin/bash
          
          # Unset problematic session managers
          unset SESSION_MANAGER
          unset DBUS_SESSION_BUS_ADDRESS
          
          # Export essential X11 environment variables
          export XDG_CURRENT_DESKTOP="XFCE"
          export XDG_SESSION_TYPE="x11"
          export XDG_SESSION_DESKTOP="xfce"
          
          # Disable accessibility bus (causes warnings in headless)
          export NO_AT_BRIDGE=1
          
          # Start DBus session bus (critical for XFCE panels)
          if [ -z "$DBUS_SESSION_BUS_ADDRESS" ]; then
            eval $(dbus-launch --sh-syntax --exit-with-session)
          fi
          
          # Load X resources
          [ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources
          
          # Set solid background
          xsetroot -solid "#2E3440"
          
          # Start VNC config panel (iconic mode)
          vncconfig -iconic &
          
          # Start XFCE4 session
          startxfce4
          EOF
          
          chmod +x ~/.vnc/xstartup
          
          # Disable XFCE4 session save/restore (prevents state conflicts)
          mkdir -p ~/.config/xfce4/xfconf/xfce-perchannel-xml
          cat > ~/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-session.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <channel name="xfce4-session" version="1.0">
            <property name="general" type="empty">
              <property name="SaveOnExit" type="bool" value="false"/>
              <property name="SessionName" type="string" value="Default"/>
            </property>
          </channel>
          EOF
          
          # Create workspace directory
          mkdir -p ~/Desktop/workspace
          
          echo "‚úÖ VNC configured with XFCE4"

      - name: üöÄ Start VNC Server
        run: |
          echo "üöÄ Starting VNC server on port ${{ env.VNC_PORT }}..."
          
          # Ensure XDG runtime directory exists
          export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
          mkdir -p "$XDG_RUNTIME_DIR"
          chmod 700 "$XDG_RUNTIME_DIR"
          
          # Start VNC server with XFCE4
          vncserver ${{ env.VNC_DISPLAY }} \
            -geometry ${{ env.VNC_GEOMETRY }} \
            -depth ${{ env.VNC_DEPTH }} \
            -localhost no \
            -alwaysshared
          
          # Wait for VNC to fully initialize
          sleep 8
          
          # Verify VNC is running
          if pgrep -f "Xtigervnc.*${{ env.VNC_DISPLAY }}" > /dev/null; then
            echo "‚úÖ VNC Server running on display ${{ env.VNC_DISPLAY }} (port ${{ env.VNC_PORT }})"
            echo "üìä VNC Process:"
            pgrep -a Xtigervnc
          else
            echo "‚ùå VNC Server failed to start"
            echo "üìã VNC Logs:"
            cat ~/.vnc/*.log 2>/dev/null || echo "No logs found"
            exit 1
          fi

      - name: ‚òÅÔ∏è Setup Cloudflare Tunnel
        run: |
          echo "üåê Setting up Cloudflare tunnel..."
          
          # Install cloudflared
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          rm cloudflared-linux-amd64.deb
          
          # Start tunnel pointing to VNC port
          cloudflared tunnel --url tcp://localhost:${{ env.VNC_PORT }} > /tmp/cloudflare.log 2>&1 &
          
          # Wait for tunnel establishment
          echo "‚è≥ Waiting for Cloudflare tunnel..."
          sleep 10
          
          # Extract and verify hostname
          TUNNEL_READY=false
          for i in {1..30}; do
            if grep -q "https://" /tmp/cloudflare.log 2>/dev/null; then
              HOSTNAME=$(grep -oP "https://\K[^[:space:]]+" /tmp/cloudflare.log | grep -m1 "trycloudflare.com")
              if [ -n "$HOSTNAME" ]; then
                echo "$HOSTNAME" > /tmp/cf_host.txt
                echo "‚úÖ Cloudflare tunnel established"
                echo "üîó Hostname: $HOSTNAME"
                TUNNEL_READY=true
                break
              fi
            fi
            sleep 2
          done
          
          if [ "$TUNNEL_READY" = false ]; then
            echo "‚ö†Ô∏è  Tunnel may still be initializing..."
            echo "üìã Recent logs:"
            tail -15 /tmp/cloudflare.log 2>/dev/null || echo "No logs available yet"
          fi

      - name: üêç Install Python Development Environment
        run: |
          echo "üêç Installing Python..."
          sudo apt-get install -y \
            python3 \
            python3-pip \
            python3-venv \
            python3-dev
          
          python3 --version
          pip3 --version
          echo "‚úÖ Python environment ready"

      - name: üì¶ Install Node.js Development Environment
        run: |
          echo "üì¶ Installing Node.js LTS..."
          curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          node --version
          npm --version
          echo "‚úÖ Node.js environment ready"

      - name: üíª Install Visual Studio Code
        run: |
          echo "üíª Installing VS Code..."
          
          # Add Microsoft GPG key
          wget -qO- https://packages.microsoft.com/keys/microsoft.asc | \
            gpg --dearmor > /tmp/packages.microsoft.gpg
          sudo install -D -o root -g root -m 644 \
            /tmp/packages.microsoft.gpg \
            /etc/apt/keyrings/packages.microsoft.gpg
          
          # Add VS Code repository
          echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main" | \
            sudo tee /etc/apt/sources.list.d/vscode.list > /dev/null
          
          # Install
          sudo apt-get update -qq
          sudo apt-get install -y code
          
          # Cleanup
          rm /tmp/packages.microsoft.gpg
          
          code --version
          echo "‚úÖ VS Code installed"

      - name: üöÄ Install Antigravity IDE
        run: |
          echo "üöÄ Installing Antigravity IDE..."
          
          # Add Antigravity GPG key
          curl -fsSL https://us-central1-apt.pkg.dev/doc/repo-signing-key.gpg | \
            sudo gpg --dearmor -o /etc/apt/keyrings/antigravity.gpg
          
          # Add Antigravity repository
          echo "deb [signed-by=/etc/apt/keyrings/antigravity.gpg] https://us-central1-apt.pkg.dev/projects/antigravity-auto-updater-dev/ antigravity-debian main" | \
            sudo tee /etc/apt/sources.list.d/antigravity.list > /dev/null
          
          # Install
          sudo apt-get update -qq
          sudo apt-get install -y antigravity
          
          antigravity --version
          echo "‚úÖ Antigravity IDE installed"

      - name: ‚öôÔ∏è Configure Git
        run: |
          echo "‚öôÔ∏è Configuring Git..."
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global init.defaultBranch main
          git config --global core.autocrlf input
          
          echo "‚úÖ Git configured for: ${GITHUB_ACTOR}"

      - name: üì• Restore Projects from Backup
        run: |
          echo "üì• Checking for project backups..."
          
          # Determine authentication token
          TOKEN="${{ secrets.GH_TOKEN }}"
          [ -z "$TOKEN" ] && TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          BACKUP_REPO_URL="https://x-access-token:${TOKEN}@github.com/${GITHUB_ACTOR}/${{ env.BACKUP_REPO }}.git"
          
          # Check if backup repository exists
          if git ls-remote "$BACKUP_REPO_URL" &>/dev/null; then
            echo "üìÇ Backup repository found - restoring projects..."
            
            # Clone backup index
            git clone --depth=1 "$BACKUP_REPO_URL" /tmp/backup-index
            
            # Restore each project listed in README
            if [ -f /tmp/backup-index/README.md ]; then
              RESTORE_COUNT=0
              
              while IFS= read -r REPO_PATH; do
                [ -z "$REPO_PATH" ] && continue
                
                REPO_NAME=$(basename "$REPO_PATH")
                echo "  üì¶ Restoring: $REPO_NAME"
                
                if git clone --depth=1 \
                  "https://x-access-token:${TOKEN}@github.com/${REPO_PATH}.git" \
                  "$HOME/Desktop/workspace/${REPO_NAME}" 2>/dev/null; then
                  RESTORE_COUNT=$((RESTORE_COUNT + 1))
                  echo "    ‚úÖ Restored successfully"
                else
                  echo "    ‚ö†Ô∏è  Failed to restore"
                fi
              done < <(grep -oP '^\s*-\s*\K\S+' /tmp/backup-index/README.md)
              
              echo "‚úÖ Restored $RESTORE_COUNT project(s)"
            fi
            
            rm -rf /tmp/backup-index
            
          else
            echo "üìù No backup repository found - creating new one..."
            
            # Initialize new backup repository
            mkdir -p /tmp/new-backup
            cd /tmp/new-backup
            
            cat > README.md << 'EOFREADME'
          # üìÇ Project Backup Index
          
          This repository maintains a list of all backed-up projects.
          
          ## Backed Up Projects
          
          EOFREADME
            
            git init
            git add README.md
            git commit -m "Initialize backup repository"
            git branch -M main
            
            # Create repository via GitHub API
            HTTP_STATUS=$(curl -s -o /tmp/api_response.json -w "%{http_code}" \
              -X POST \
              -H "Authorization: token ${TOKEN}" \
              -H "Content-Type: application/json" \
              https://api.github.com/user/repos \
              -d "{\"name\":\"${{ env.BACKUP_REPO }}\",\"private\":true,\"description\":\"Automated project backup index\"}")
            
            if [ "$HTTP_STATUS" -eq 201 ] || [ "$HTTP_STATUS" -eq 422 ]; then
              echo "‚úÖ Backup repository created/verified"
              sleep 3
              
              # Push initial commit
              git remote add origin "$BACKUP_REPO_URL"
              if git push -u origin main 2>/dev/null; then
                echo "‚úÖ Initial backup index pushed"
              else
                echo "‚ö†Ô∏è  Push failed - repository may need time to initialize"
              fi
            else
              echo "‚ö†Ô∏è  API response: $(cat /tmp/api_response.json 2>/dev/null)"
            fi
            
            cd ~
            rm -rf /tmp/new-backup /tmp/api_response.json
          fi

      - name: üîÑ Deploy Improved Backup Watcher Service
        run: |
          echo "üîß Deploying improved backup watcher service..."
          
          # Determine authentication token
          TOKEN="${{ secrets.GH_TOKEN }}"
          [ -z "$TOKEN" ] && TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          # Create improved backup watcher with HYBRID approach (inotify + periodic scan)
          cat > ~/backup-watcher.sh << 'EOFWATCHER'
          #!/bin/bash
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # IMPROVED BACKUP WATCHER v2.0
          # Features:
          #   1. Real-time monitoring via inotifywait
          #   2. Periodic scanning for missed projects (every 5 minutes)
          #   3. Tracked projects file to avoid duplicates
          #   4. Better error handling and logging
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          
          # Configuration
          WATCH_DIR="$HOME/Desktop/workspace"
          GITHUB_USER="GITHUB_USER_PLACEHOLDER"
          BACKUP_REPO="backup-files"
          TOKEN="TOKEN_PLACEHOLDER"
          LOCK_FILE="$HOME/.backup-watcher.lock"
          LOG_FILE="$HOME/backup-watcher.log"
          TRACKED_FILE="$HOME/.backed-up-projects"
          SCAN_INTERVAL=300  # 5 minutes
          
          # Initialize tracked projects file
          touch "$TRACKED_FILE"
          
          log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
          }
          
          is_already_backed_up() {
            local PROJECT_NAME="$1"
            grep -qx "$PROJECT_NAME" "$TRACKED_FILE" 2>/dev/null
          }
          
          mark_as_backed_up() {
            local PROJECT_NAME="$1"
            echo "$PROJECT_NAME" >> "$TRACKED_FILE"
          }
          
          backup_project() {
            local PROJECT_PATH="$1"
            local PROJECT_NAME=$(basename "$PROJECT_PATH")
            
            # Skip if already tracked
            if is_already_backed_up "$PROJECT_NAME"; then
              return 0
            fi
            
            # Skip empty directories
            if [ -z "$(ls -A "$PROJECT_PATH" 2>/dev/null)" ]; then
              log "‚è≠Ô∏è  Skipping empty project: $PROJECT_NAME"
              return 0
            fi
            
            # Skip if already initialized as git repo with remote
            if [ -d "$PROJECT_PATH/.git" ]; then
              if cd "$PROJECT_PATH" && git remote -v | grep -q "github.com"; then
                log "‚è≠Ô∏è  Already has GitHub remote: $PROJECT_NAME"
                mark_as_backed_up "$PROJECT_NAME"
                return 0
              fi
            fi
            
            log "üì§ Backing up project: $PROJECT_NAME"
            
            # Create GitHub repository
            HTTP_STATUS=$(curl -s -o /tmp/repo_create_$$.json -w "%{http_code}" \
              -X POST \
              -H "Authorization: token $TOKEN" \
              -H "Content-Type: application/json" \
              https://api.github.com/user/repos \
              -d "{\"name\":\"$PROJECT_NAME\",\"private\":true,\"auto_init\":false}")
            
            if [ "$HTTP_STATUS" -ne 201 ] && [ "$HTTP_STATUS" -ne 422 ]; then
              log "‚ùå Failed to create repository (HTTP $HTTP_STATUS)"
              cat /tmp/repo_create_$$.json >> "$LOG_FILE" 2>/dev/null
              rm -f /tmp/repo_create_$$.json
              return 1
            fi
            
            sleep 2
            rm -f /tmp/repo_create_$$.json
            
            # Navigate to project
            cd "$PROJECT_PATH" || return 1
            
            # Initialize git if needed
            if [ ! -d ".git" ]; then
              git init
              log "  ‚úÖ Git initialized"
            fi
            
            # Add all files
            git add -A
            
            # Commit if there are changes
            if git diff --cached --quiet 2>/dev/null; then
              log "  ‚ÑπÔ∏è  No changes to commit"
            else
              git commit -m "Auto-backup from cloud workstation - $(date '+%Y-%m-%d %H:%M')" 2>/dev/null
              log "  ‚úÖ Changes committed"
            fi
            
            # Ensure main branch
            git branch -M main 2>/dev/null
            
            # Add or update remote
            git remote remove origin 2>/dev/null
            git remote add origin "https://x-access-token:$TOKEN@github.com/$GITHUB_USER/$PROJECT_NAME.git"
            
            # Push
            if git push -u origin main --force 2>/dev/null; then
              log "‚úÖ Pushed to GitHub: $PROJECT_NAME"
              mark_as_backed_up "$PROJECT_NAME"
              
              # Update backup index (with file locking)
              (
                flock 200
                
                rm -rf /tmp/backup-index-update-$$
                
                if git clone --depth=1 "https://x-access-token:$TOKEN@github.com/$GITHUB_USER/$BACKUP_REPO.git" /tmp/backup-index-update-$$ 2>/dev/null; then
                  cd /tmp/backup-index-update-$$
                  
                  # Add to index if not already present
                  if ! grep -q "$GITHUB_USER/$PROJECT_NAME" README.md 2>/dev/null; then
                    echo "- $GITHUB_USER/$PROJECT_NAME" >> README.md
                    git add README.md
                    git commit -m "Add $PROJECT_NAME to backup index" 2>/dev/null
                    git push 2>/dev/null
                    log "‚úÖ Updated backup index"
                  fi
                  
                  cd ~
                  rm -rf /tmp/backup-index-update-$$
                fi
              ) 200>$LOCK_FILE
              
            else
              log "‚ùå Failed to push: $PROJECT_NAME"
              return 1
            fi
            
            return 0
          }
          
          process_new_project() {
            local PROJECT_PATH="$1"
            local PROJECT_NAME=$(basename "$PROJECT_PATH")
            
            log "üìÅ Detected new project: $PROJECT_NAME"
            
            # Wait for project to stabilize (files being copied)
            sleep 10
            
            backup_project "$PROJECT_PATH"
          }
          
          periodic_scan() {
            while true; do
              sleep $SCAN_INTERVAL
              
              log "üîç Running periodic scan..."
              
              # Scan all directories in workspace
              for dir in "$WATCH_DIR"/*/; do
                [ -d "$dir" ] || continue
                
                PROJECT_NAME=$(basename "$dir")
                
                # Skip already tracked
                if is_already_backed_up "$PROJECT_NAME"; then
                  continue
                fi
                
                log "üîç Found untracked project: $PROJECT_NAME"
                backup_project "$dir"
              done
              
              log "üîç Periodic scan complete"
            done
          }
          
          # Export functions for subshells
          export -f backup_project
          export -f process_new_project
          export -f log
          export -f is_already_backed_up
          export -f mark_as_backed_up
          export WATCH_DIR GITHUB_USER BACKUP_REPO TOKEN LOCK_FILE LOG_FILE TRACKED_FILE
          
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          # MAIN EXECUTION
          # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          
          log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          log "üëÅÔ∏è  BACKUP WATCHER v2.0 STARTED"
          log "   üìÇ Watching: $WATCH_DIR"
          log "   üë§ GitHub User: $GITHUB_USER"
          log "   üîÑ Scan Interval: ${SCAN_INTERVAL}s"
          log "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Initial scan for existing projects
          log "üîç Running initial scan for existing projects..."
          for dir in "$WATCH_DIR"/*/; do
            [ -d "$dir" ] || continue
            backup_project "$dir"
          done
          log "üîç Initial scan complete"
          
          # Start periodic scanner in background
          periodic_scan &
          SCANNER_PID=$!
          log "üîÑ Periodic scanner started (PID: $SCANNER_PID)"
          
          # Start real-time watcher
          log "üëÅÔ∏è  Starting real-time file watcher..."
          inotifywait -m -e create -e moved_to --format '%w%f' "$WATCH_DIR" 2>/dev/null | while read NEW_PATH; do
            if [ -d "$NEW_PATH" ]; then
              process_new_project "$NEW_PATH" &
            fi
          done
          EOFWATCHER
          
          # Inject actual values
          sed -i "s|TOKEN_PLACEHOLDER|${TOKEN}|g" ~/backup-watcher.sh
          sed -i "s|GITHUB_USER_PLACEHOLDER|${GITHUB_ACTOR}|g" ~/backup-watcher.sh
          chmod +x ~/backup-watcher.sh
          
          # Start watcher service
          nohup bash ~/backup-watcher.sh > /dev/null 2>&1 &
          WATCHER_PID=$!
          
          # Wait a moment and verify
          sleep 3
          if pgrep -f "backup-watcher.sh" > /dev/null; then
            echo "‚úÖ Backup watcher v2.0 deployed (PID: $WATCHER_PID)"
            echo "üìã Features:"
            echo "   ‚Ä¢ Real-time detection via inotifywait"
            echo "   ‚Ä¢ Periodic scan every 5 minutes"
            echo "   ‚Ä¢ Automatic initial scan on startup"
            echo "   ‚Ä¢ Better duplicate handling"
          else
            echo "‚ùå Watcher failed to start"
            cat ~/backup-watcher.log
          fi

      - name: üí° Keep Alive & Connection Info
        run: |
          CLOUDFLARE_HOST=$(cat /tmp/cf_host.txt 2>/dev/null || echo "")
          
          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë                                                            ‚ïë"
          echo "‚ïë    üöÄ LINUX CLOUD WORKSTATION READY  üöÄ                    ‚ïë"
          echo "‚ïë              (With Improved Backup v2.0)                   ‚ïë"
          echo "‚ïë                                                            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""
          
          if [ -n "$CLOUDFLARE_HOST" ]; then
            echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
            echo "‚îÇ STEP 1: Run on your LOCAL machine                          ‚îÇ"
            echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            echo ""
            echo "cloudflared access tcp --hostname $CLOUDFLARE_HOST --url 127.0.0.1:${{ env.VNC_PORT }}"
            echo ""
            echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
            echo "‚îÇ üñ•Ô∏è  STEP 2: Connect with VNC Viewer                         ‚îÇ"
            echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            echo ""
            echo "  Server:   localhost:${{ env.VNC_PORT }}"
            if [ -n "${{ secrets.VNC_PASSWORD }}" ]; then
              echo "  Password: [Your VNC_PASSWORD secret]"
            else
              echo "  Password: P@ssw0rd123!"
            fi
            echo ""
          else
            echo "‚ö†Ô∏è  Cloudflare tunnel still initializing..."
            echo "    Check 'Setup Cloudflare Tunnel' step above"
          fi
          
          echo ""
          echo "üìä Environment Details:"
          echo "  üñ•Ô∏è  OS:          Ubuntu Linux"
          echo "  üñ•Ô∏è  Desktop:     XFCE4"
          echo "  üë§ User:        ${USER}"
          echo "  üìÇ Workspace:   ~/Desktop/workspace"
          echo "  ‚è±Ô∏è  Duration:    6 hours"
          echo "  üîÑ Backup:      Auto-sync v2.0"
          echo ""
          
          # Health monitoring loop
          RESTART_COUNT=0
          MAX_RESTARTS=5
          
          while true; do
            sleep 1800
            
            # VNC health check
            if ! pgrep -f "Xtigervnc.*${{ env.VNC_DISPLAY }}" > /dev/null; then
              if [ $RESTART_COUNT -lt $MAX_RESTARTS ]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] ‚ö†Ô∏è  VNC disconnected - restarting..."
                
                export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"
                
                vncserver ${{ env.VNC_DISPLAY }} \
                  -geometry ${{ env.VNC_GEOMETRY }} \
                  -depth ${{ env.VNC_DEPTH }} \
                  -localhost no \
                  -alwaysshared
                
                sleep 5
                
                if pgrep -f "Xtigervnc.*${{ env.VNC_DISPLAY }}" > /dev/null; then
                  RESTART_COUNT=$((RESTART_COUNT + 1))
                  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ‚úÖ VNC restarted (attempt $RESTART_COUNT/$MAX_RESTARTS)"
                fi
              fi
            fi
            
            # Backup watcher health check
            if ! pgrep -f "backup-watcher.sh" > /dev/null; then
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] üîÑ Restarting backup watcher..."
              nohup bash ~/backup-watcher.sh > /dev/null 2>&1 &
            fi
          done
